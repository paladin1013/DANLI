from enum import Enum
from pprint import pprint
from typing import Any, Dict, List
from model.model.gpt_api import GPTAPI
import logging
from definitions.teach_tasks import GoalArguments, GoalReceptacles, GoalConditions
from difflib import get_close_matches


class Operation(Enum):
    Cook = 1
    Clean = 2
    PickUp = 3
    FillWithLiquid = 4
    Empty = 5
    Slice = 6
    Boil = 7
    FillWithCoffee = 8


class ActionType(Enum):
    Manipulate = 0
    Place = 1


class LLMSubgoalPredictor:
    def __init__(self):
        self.gpt_api = GPTAPI(log_level=logging.DEBUG)
        self.explanation_level = "brief"
        self.logger = logging.getLogger("subgoal_predictor")
        
    def parse_edh_data(self, edh_raw, text_dialog_and_act):
        objects = edh_raw['init_state_diff']['objects']
        
        text_dialog_and_act = text_dialog_and_act
        
        valid_objects:List[str] = []
        valid_receptacles:Dict[str, List[str]] = {}
        for key, value in objects.items():
            name = key.split('|')[0]
            if name not in valid_objects:
                valid_objects.append(name)
            # dist = value['distance']
            if 'receptacleObjectIds' in value.keys():
                recept_names = [recept_str.split('|')[0] for recept_str in value['receptacleObjectIds']]
                # Remove replicated elements in recept_names
                recept_names = list(set(recept_names))
                valid_receptacles.update({name: recept_names})
        edh_session = {}
        edh_session['objects'] = valid_objects
        edh_session['receptacles'] = valid_receptacles
        edh_session['history'] = text_dialog_and_act
        return edh_session

    def gen_edh_prompt(self, edh_session: Dict[str, Any]):
        intro = "Suppose you are a household robot and your user will give you some tasks with language instructions. You need to propose some subgoals to complete this goal. Each subgoal can either be a manipulation action or a placing action. For a manipulation action, you need to specify the operation and the object. For a placing action, you need to specify the object and the receptacle. All the possible objects, operations, and receptacles are listed as below. "

        objects: List[str] = edh_session["objects"]
        receptacles: Dict[str, List[str]] = edh_session["receptacles"]
        history: str = edh_session["history"]

        objects_str = "Valid objects: " + ", ".join(objects) + ". "
        operations_str = (
            "Valid operations: " + ", ".join([op.name for op in Operation]) + ". "
        )

        receptacles_str = (
            "Valid receptacles with valid objects in the following bracket: "
        )
        for receptacle, valid_objects in receptacles.items():
            receptacles_str += receptacle + " (" + ", ".join(valid_objects) + "), "
        receptacles_str += ". "

        history_str = f"Please consider the state after following dialogue and action history.\n{history}"

        end_str = f"Please predict a series of subgoals in the format 'Manipulate (operation, objcect)' or 'Place (object, receptacle)' with {self.explanation_level} explanations. Note that you can only hold one object at a time. You have to place the object you are holding before you can pick up another object."

        return f"{intro}\n\n{objects_str}\n\n{operations_str}\n\n{receptacles_str}\n\n{history_str}\n\n{end_str}"

    def gen_formatting_prompt(self):
        return "Please format your predicted subgoals with format 'Manipulate(object, operation)' or 'Place(object, receptacle)' and remove the explanations. object, operation and receptacle can be any one of the valid items above.\nFor example:\n1. Manipulate(PickUp, Knife)\n2. Place(Knife, Sink)"

    def match_terms(self, input_str: str, input_type: str):
        if input_type == "object":
            enums = GoalArguments
        elif input_type == "operation":
            enums = GoalConditions
        elif input_type == "receptacle":
            enums = GoalReceptacles
        else:
            raise (
                ValueError(
                    f"input_type should be one of 'object', 'operation', 'receptacle', but got {input_type} instead."
                )
            )
        valid_list = [item.name for item in enums]
        valid = get_close_matches(input_str, valid_list, n=1)
        if not valid:
            raise (ValueError(f"{input_str} cannot match a valid {input_type}."))
        return enums[valid[0]]

    def parse_gpt_reply(self, gpt_reply: str, output_style: str = "DANLI"):
        """Parse the reply message generated by GPT. The out put will adapt to the structure according to `output_style`
        "DANLI": (pred, subj, obj)
        "new": (Manipulate, object, operation) or (Place, object, receptacle)
        """
        subgoals = []
        idx = 1
        for line in gpt_reply.splitlines():
            # Match the format "1. Manipulate(PickUp, Knife)" with ascending idx
            # TODO: add more checks to make sure the format is correct
            if "Manipulate" in line:
                operation, object = line.split("(")[1].split(")")[0].split(", ")
                operation = self.match_terms(operation, "operation")
                object = self.match_terms(object, "object")
                subgoals.append((ActionType.Manipulate, operation, object))

            elif "Place" in line:
                object, receptacle = line.split("(")[1].split(")")[0].split(", ")
                object = self.match_terms(object, "object")
                receptacle = self.match_terms(receptacle, "receptacle")
                subgoals.append((ActionType.Place, object, receptacle))

        if output_style == "new":
            return subgoals
        elif output_style == "DANLI":
            subgoals_DANLI = []
            for subgoal in subgoals:
                if subgoal[0] == ActionType.Manipulate:
                    operation = self.match_terms(subgoal[1].name, "operation")
                    object = self.match_terms(subgoal[2].name, "object")
                    subgoals_DANLI.append((operation, object, GoalReceptacles.NONE))
                elif subgoal[0] == ActionType.Place:
                    object = self.match_terms(subgoal[1].name, "object")
                    receptacle = self.match_terms(subgoal[1].name, "receptacle")
                    subgoals_DANLI.append(
                        (GoalConditions.parentReceptacles, object, receptacle)
                    )
            subgoals_DANLI.append(
                (GoalConditions.EOS, GoalArguments.NONE, GoalReceptacles.NONE)
            )
            return subgoals_DANLI
        else:
            raise NotImplementedError(
                f"output_style {output_style} has not been implemented yet."
            )

    def predict(self, edh_session: Dict[str, Any]):
        replies = self.gpt_api.send(
            [self.gen_edh_prompt(edh_session), self.gen_formatting_prompt()]
        )
        subgoals = self.parse_gpt_reply(replies[1])
        return subgoals


if __name__ == "__main__":
    predictor = LLMSubgoalPredictor()
    # edh_session = edh_file_parser(game_id="24ed9868107a2701_c467", edh_id=0)
    # print(predictor.predict(edh_session))

    test_reply = """1. Place(Potato, CounterTop)
2. Manipulate(PickUp, Knife)
3. Manipulate(PickUp, Potato)
4. Place(Potato, Pot)
5. Manipulate(PickUp, Potato)
6. Place(Potato, Pot)
7. Manipulate(FillWithLiquid, Pot)
8. Place(Pot, StoveBurner)
9. Manipulate(Cook, Pot)
10. Place(Pot, CounterTop)
11. Manipulate(PickUp, Plate)
12. Place(Potatoes, Plate)
"""
    pprint(predictor.parse_gpt_reply(test_reply))
